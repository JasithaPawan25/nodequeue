"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class SymbolTable {
    constructor(symbolKeyProvider) {
        this.localLookup = (key, type = undefined, parent = undefined) => {
            return this.lookupInternal(this.symbols, key, type, parent);
        };
        this.lookup = (key, type = undefined, parent = undefined) => {
            let keyToLookup = this.getKey(key);
            let result = this.localLookup(keyToLookup, type, parent);
            return (result && result.length)
                ? result
                : (this.parent ? this.parent.lookup(keyToLookup, type, parent) : undefined);
        };
        this.symbols = new Map();
        this.keyFunc = symbolKeyProvider || (s => s.identifier !== undefined ? s.identifier : s.toString());
        this.allowDuplicates = true;
        this._globalSymbols = this.symbols;
    }
    enterScope() {
        let newParent = new SymbolTable(this.keyFunc);
        newParent.symbols = this.symbols;
        newParent.parent = this.parent;
        newParent._globalSymbols = this._globalSymbols;
        this.parent = newParent;
        this.symbols = new Map();
    }
    exitScope() {
        if (!this.parent) {
            throw Error("Already at the root scope");
        }
        this.symbols = this.parent.symbols;
        this.parent = this.parent.parent;
    }
    add(key, value) {
        this.addSymbol(key, value, this.symbols);
    }
    addToGlobalScope(key, value) {
        this.addSymbol(key, value, this._globalSymbols);
    }
    *[Symbol.iterator]() {
        for (let sym of this.symbols.values()) {
            yield* sym;
        }
        if (this.parent) {
            let gen = this.parent[Symbol.iterator]();
            if (gen) {
                yield* gen;
            }
        }
    }
    getKey(key) {
        return typeof key === "string" ? key : this.keyFunc(key);
    }
    lookupInternal(map, key, type = undefined, parent = undefined) {
        let matchedSymbols = map.get(this.getKey(key));
        let result = [];
        if (matchedSymbols && matchedSymbols.length) {
            for (let s of matchedSymbols) {
                if ((type === undefined || s.type === type) && (parent === undefined || s.parent === parent)) {
                    result.push(s);
                }
            }
        }
        return (result && result.length) ? result : undefined;
    }
    addSymbol(key, value, map) {
        value = value || key;
        key = this.getKey(key);
        let matchedSymbols = map.get(key);
        if (matchedSymbols) {
            if (!this.allowDuplicates) {
                throw Error(`Symbol ${key} already found in desired scope`);
            }
            for (let s of matchedSymbols) {
                if (s.type === value.type && s.parent === value.parent) {
                    throw Error(`Symbol ${key} already found in desired scope`);
                }
            }
            matchedSymbols.push(value);
        }
        else {
            map.set(key, [value]);
        }
    }
}
exports.SymbolTable = SymbolTable;
//# sourceMappingURL=index.js.map