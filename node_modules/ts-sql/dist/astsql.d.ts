import { AstSymbol } from "jsymbol";
import "reflect-metadata";
export declare type SqlDialect = "MySQL" | "Custom";
export declare type SelectAll = "*";
export declare type NotOperator = "NOT" | "!";
export declare type UnaryOperator = NotOperator | "~" | "+" | "-";
export declare type ComparisonOperator = "=" | ">" | "<" | ">=" | "<=" | "!=" | "<=>";
export declare type LogicalOperator = "AND" | "OR" | "XOR" | "&&" | "||";
export declare type BitOperator = "<<" | ">>" | "&" | "|" | "^";
export declare type MathOperator = "*" | "/" | "DIV" | "MOD" | "%" | "+" | "-";
export declare type NullLiteral = "NULL" | "NOT NULL";
export declare type ConstantType = string | number | boolean | NullLiteral;
export declare type BinaryOperator = ComparisonOperator | LogicalOperator | BitOperator | MathOperator;
export declare type SortType = "ASC" | "DESC";
export declare type All = "ALL";
export declare type Distinct = "DISTINCT";
export declare type SelectSpec = All | Distinct | "DISTINCTROW" | "HIGH_PRIORITY" | "STRAIGHT_JOIN" | "SQL_SMALL_RESULT" | "SQL_BIG_RESULT" | "SQL_BUFFER_RESULT" | "SQL_CACHE" | "SQL_NO_CACHE" | "SQL_CALC_FOUND_ROWS";
export declare type LockClause = "FOR UPDATE" | "LOCK IN SHARE MODE";
export declare type Quantifier = "ALL" | "SOME" | "ANY";
export declare type IntervalTypeBase = "QUARTER" | "MONTH" | "DAY" | "HOUR" | "MINUTE" | "WEEK" | "SECOND" | "MICROSECOND";
export declare type IntervalType = IntervalTypeBase | "YEAR" | "YEAR_MONTH" | "DAY_HOUR" | "DAY_MINUTE" | "DAY_SECOND" | "HOUR_MINUTE" | "HOUR_SECOND" | "MINUTE_SECOND" | "SECOND_MICROSECOND" | "MINUTE_MICROSECOND" | "HOUR_MICROSECOND" | "DAY_MICROSECOND";
export declare type JoinType = "INNER" | "CROSS" | "LEFT OUTER" | "RIGHT OUTER";
export declare enum SqlSymbolType {
    Table = 0,
    Field = 1,
    Variable = 2,
    Alias = 3,
    Function = 4,
}
export declare enum SqlNodeType {
    Undefined = 0,
    NotImplemented = 1,
    SqlRoot = 2,
    SelectStatement = 3,
    QueryExpression = 4,
    QueryIntoExpression = 5,
    UnionGroupStatement = 6,
    UnionStatement = 7,
    AllColumns = 8,
    ColumnName = 9,
    SimpleFunctionCall = 10,
    CaseExpression = 11,
    CaseBranchExpression = 12,
    Constant = 13,
    AliasedTerm = 14,
    AssignedTerm = 15,
    NotExpression = 16,
    BinaryExpression = 17,
    TruthyPredicate = 18,
    InPredicate = 19,
    IsNullNotNullPredicate = 20,
    BinaryPredicate = 21,
    QuantifiedSelectStatement = 22,
    BetweenPredicate = 23,
    SoundsLikePredicate = 24,
    LikePredicate = 25,
    AssignedExpressionAtom = 26,
    Variable = 27,
    UnaryExpressionAtom = 28,
    BinaryModifiedExpression = 29,
    RowExpression = 30,
    IntervalExpression = 31,
    BinaryExpressionAtom = 32,
    NestedSelectStatement = 33,
    ExistsSelectStatement = 34,
    FromClause = 35,
    TableSource = 36,
    TableSpec = 37,
    WhereClause = 38,
    GroupByClause = 39,
    GroupByItem = 40,
    JoinClause = 41,
    OrderByClause = 42,
    OrderByExpression = 43,
    LimitClause = 44,
    SelectIntoFieldsExpression = 45,
}
export declare const NodeTypeKey: unique symbol;
export declare const SqlNodeMarker: (nodeType: SqlNodeType) => <TNode extends new (...args: any[]) => SqlAstNode>(constructor: TNode) => {
    new (...args: any[]): {
        nodeType: SqlNodeType;
    };
} & TNode;
export declare function getSqlNodeType(node: SqlAstNode): string;
export declare type SqlSymbol<T = {}> = string | AstSymbol<T>;
export declare abstract class SqlAstNode {
    static getNodeType(node: SqlAstNode): string;
}
export declare class NotImplemented extends SqlAstNode {
}
export declare class SqlRoot extends SqlAstNode {
    dialect: string;
    statements: SqlStatement[];
    constructor(dialect: string, statements?: SqlStatement[]);
}
export declare type SqlStatement = DdlStatement | DmlStatement | TransactionStatement | ReplicationStatement | PreparedStatement | AdministrationStatement | UtilityStatement;
export declare type DdlStatement = NotImplemented;
export declare type TransactionStatement = NotImplemented;
export declare type ReplicationStatement = NotImplemented;
export declare type PreparedStatement = NotImplemented;
export declare type AdministrationStatement = NotImplemented;
export declare type UtilityStatement = NotImplemented;
export declare type DmlStatement = SelectStatement | InsertStatement | UpdateStatement | DeleteStatement | ReplaceStatement | CallStatement | LoadDataStatement | LoadXmlStatement | DoStatement | HandlerStatement;
export declare type InsertStatement = NotImplemented;
export declare type UpdateStatement = NotImplemented;
export declare type DeleteStatement = NotImplemented;
export declare type ReplaceStatement = NotImplemented;
export declare type CallStatement = NotImplemented;
export declare type LoadDataStatement = NotImplemented;
export declare type LoadXmlStatement = NotImplemented;
export declare type DoStatement = NotImplemented;
export declare type HandlerStatement = NotImplemented;
export declare class SelectStatement extends SqlAstNode {
    query: QueryIntoExpression | UnionGroupStatement;
    lock?: LockClause;
    constructor(query: QueryIntoExpression | UnionGroupStatement);
}
export declare class QueryExpression extends SqlAstNode {
    selectSpec?: SelectSpec[];
    selectAll?: SelectAll;
    elements: SelectElement[];
    from?: FromClause;
    orderBy?: OrderByClause;
    limit?: LimitClause;
    constructor(elements?: SelectElement[]);
}
export declare class QueryIntoExpression extends SqlAstNode {
    query: QueryExpression;
    into?: SelectIntoExpression;
    constructor(query: QueryExpression);
}
export declare class UnionStatement extends SqlAstNode {
    unionWith: QueryExpression;
    unionType?: All | Distinct;
    constructor(unionWith: QueryExpression, unionType?: All | Distinct);
}
export declare class UnionGroupStatement extends SqlAstNode {
    query: QueryExpression;
    unions?: UnionStatement[];
    unionType?: All | Distinct;
    unionLast?: QueryIntoExpression;
    orderBy?: OrderByClause;
    limit?: LimitClause;
    constructor(query: QueryExpression);
}
export declare type SelectElement = AllColumns | ColumnName | FunctionCall | Expression | AssignedTerm<Expression> | AliasedTerm<ColumnName> | AliasedTerm<FunctionCall> | AliasedTerm<AssignedTerm<Expression>>;
export declare class AllColumns extends SqlAstNode {
    table: SqlSymbol;
    constructor(table: SqlSymbol);
}
export declare class ColumnName extends SqlAstNode {
    name: SqlSymbol;
    table: string | AstSymbol<{}> | undefined;
    constructor(name: SqlSymbol, table?: string | AstSymbol<{}> | undefined);
}
export declare type FunctionCall = SpecificFunction | AggregatedWindowFunction | SimpleFunctionCall | PasswordFunction;
export declare type SpecificFunction = CaseExpression | NotImplemented;
export declare type AggregatedWindowFunction = NotImplemented;
export declare type PasswordFunction = NotImplemented;
export declare class SimpleFunctionCall extends SqlAstNode {
    name: SqlSymbol;
    args: FunctionArgument[] | undefined;
    constructor(name: SqlSymbol, args?: FunctionArgument[] | undefined);
}
export declare class CaseExpression extends SqlAstNode {
    expression: NotImplemented | NotExpression | BinaryExpression<LogicalOperator> | TruthyPredicate | InPredicate | IsNullNotNullPredicate | BinaryPredicate | BetweenPredicate | SoundsLikePredicate | LikePredicate | AssignedExpressionAtom | undefined;
    branches: CaseBranchExpression[];
    elseBranch?: FunctionArgument;
    constructor(expression?: NotImplemented | NotExpression | BinaryExpression<LogicalOperator> | TruthyPredicate | InPredicate | IsNullNotNullPredicate | BinaryPredicate | BetweenPredicate | SoundsLikePredicate | LikePredicate | AssignedExpressionAtom | undefined);
}
export declare class CaseBranchExpression extends SqlAstNode {
    expression: FunctionArgument;
    result: FunctionArgument;
    constructor(expression: FunctionArgument, result: FunctionArgument);
}
export declare type FunctionArgument = Constant | ColumnName | FunctionCall | Expression;
export declare class Constant extends SqlAstNode {
    value: ConstantType;
    constructor(value: ConstantType);
}
export declare class AliasedTerm<TTerm extends SqlAstNode> extends SqlAstNode {
    term: TTerm;
    alias: string | AstSymbol<{}> | undefined;
    constructor(term: TTerm, alias?: string | AstSymbol<{}> | undefined);
}
export declare class AssignedTerm<TTerm extends SqlAstNode> extends SqlAstNode {
    value: TTerm;
    variable: string | AstSymbol<{}> | undefined;
    constructor(value: TTerm, variable?: string | AstSymbol<{}> | undefined);
}
export declare type Expression = NotExpression | BinaryExpression<LogicalOperator> | TruthyPredicate | Predicate;
export declare class NotExpression extends SqlAstNode {
    expression: Expression;
    constructor(expression: Expression);
}
export declare class BinaryExpression<TOperator extends BinaryOperator> extends SqlAstNode {
    left: Expression;
    operator: TOperator;
    right: Expression;
    constructor(left: Expression, operator: TOperator, right: Expression);
}
export declare class TruthyPredicate extends SqlAstNode {
    predicate: Predicate;
    negate: boolean;
    testValue: boolean | undefined;
    constructor(predicate: Predicate, negate?: boolean, testValue?: boolean | undefined);
}
export declare type Predicate = InPredicate | IsNullNotNullPredicate | BinaryPredicate | BetweenPredicate | SoundsLikePredicate | LikePredicate | RegexPredicate | AssignedExpressionAtom;
export declare class InPredicate extends SqlAstNode {
    predicate: Predicate;
    target: SelectStatement | Expression[];
    negate: boolean;
    constructor(predicate: Predicate, target: SelectStatement | Expression[], negate?: boolean);
}
export declare class IsNullNotNullPredicate extends SqlAstNode {
    predicate: Predicate;
    checkWith: NullLiteral;
    constructor(predicate: Predicate, checkWith: NullLiteral);
}
export declare class BinaryPredicate extends SqlAstNode {
    left: Predicate;
    operator: ComparisonOperator;
    right: Predicate | QuantifiedSelectStatement;
    constructor(left: Predicate, operator: ComparisonOperator, right: Predicate | QuantifiedSelectStatement);
}
export declare class QuantifiedSelectStatement extends SqlAstNode {
    quantifier: Quantifier;
    statement: SelectStatement;
    constructor(quantifier: Quantifier, statement: SelectStatement);
}
export declare class BetweenPredicate extends SqlAstNode {
    operand: Predicate;
    left: Predicate;
    right: Predicate;
    negate: boolean;
    constructor(operand: Predicate, left: Predicate, right: Predicate, negate?: boolean);
}
export declare class SoundsLikePredicate extends SqlAstNode {
    left: Predicate;
    right: Predicate;
    constructor(left: Predicate, right: Predicate);
}
export declare class LikePredicate extends SqlAstNode {
    left: Predicate;
    right: Predicate;
    negate: boolean;
    constructor(left: Predicate, right: Predicate, negate?: boolean);
}
export declare type RegexPredicate = NotImplemented;
export declare class AssignedExpressionAtom extends SqlAstNode {
    expression: ExpressionAtom;
    variable: string | AstSymbol<{}> | undefined;
    constructor(expression: ExpressionAtom, variable?: string | AstSymbol<{}> | undefined);
}
export declare type ExpressionAtom = Constant | ColumnName | FunctionCall | CollatedExpression | Variable | UnaryExpressionAtom | BinaryModifiedExpression | Expression[] | RowExpression | ExistsSelectStatement | NestedSelectStatement | BinaryExpressionAtom<BitOperator | MathOperator>;
export declare type CollatedExpression = NotImplemented;
export declare class Variable extends SqlAstNode {
    name: SqlSymbol;
    constructor(name: SqlSymbol);
}
export declare class UnaryExpressionAtom extends SqlAstNode {
    operator: UnaryOperator;
    expression: ExpressionAtom;
    constructor(operator: UnaryOperator, expression: ExpressionAtom);
}
export declare class BinaryModifiedExpression extends SqlAstNode {
    expression: ExpressionAtom;
    constructor(expression: ExpressionAtom);
}
export declare class RowExpression extends SqlAstNode {
    expressions: Expression[];
    constructor(expressions: Expression[]);
}
export declare class IntervalExpression extends SqlAstNode {
    expression: Expression;
    intervalType: IntervalType;
    constructor(expression: Expression, intervalType: IntervalType);
}
export declare class BinaryExpressionAtom<TOperator extends BinaryOperator> extends SqlAstNode {
    left: ExpressionAtom;
    operator: TOperator;
    right: ExpressionAtom;
    constructor(left: ExpressionAtom, operator: TOperator, right: ExpressionAtom);
}
export declare class NestedSelectStatement extends SqlAstNode {
    statement: SelectStatement;
    constructor(statement: SelectStatement);
}
export declare class ExistsSelectStatement extends SqlAstNode {
    statement: SelectStatement;
    constructor(statement: SelectStatement);
}
export declare type SelectIntoExpression = SelectIntoFieldsExpression | SelectIntoDumpFileExpression | SelectIntoOutFileExpression;
export declare type SelectIntoDumpFileExpression = NotImplemented;
export declare type SelectIntoOutFileExpression = NotImplemented;
export declare class FromClause extends SqlAstNode {
    tables: TableSource[];
    where?: WhereClause;
    groupBy?: GroupByClause;
    having?: Expression;
    constructor(tables: TableSource[]);
}
export declare class TableSource extends SqlAstNode {
    tableSourceItem: TableSourceItem;
    joins?: JoinClause[];
    constructor(tableSourceItem: TableSourceItem);
}
export declare type TableSourceItem = TableSpec | AliasedTerm<TableSpec | NestedSelectStatement>;
export declare class TableSpec extends SqlAstNode {
    tableName: SqlSymbol;
    partitions?: SqlSymbol[];
    indexHints?: IndexHint[];
    constructor(tableName: SqlSymbol);
}
export declare type IndexHint = NotImplemented;
export declare class WhereClause extends SqlAstNode {
    expression: Expression;
    constructor(expression: Expression);
}
export declare class GroupByClause extends SqlAstNode {
    items: GroupByItem[];
    rollup: boolean;
    constructor(items: GroupByItem[], rollup?: boolean);
}
export declare class GroupByItem extends SqlAstNode {
    expression: Expression;
    descending: boolean;
    constructor(expression: Expression, descending?: boolean);
}
export declare class JoinClause extends SqlAstNode {
    joinWith: TableSourceItem;
    joinType?: JoinType;
    on?: Expression;
    using?: SqlSymbol[];
    constructor(joinWith: TableSourceItem);
}
export declare class OrderByClause extends SqlAstNode {
    expressions: OrderByExpression[];
    constructor(expressions: OrderByExpression[]);
}
export declare class OrderByExpression extends SqlAstNode {
    expression: Expression;
    descending: boolean;
    constructor(expression: Expression, descending?: boolean);
}
export declare class LimitClause extends SqlAstNode {
    limit: number;
    offset: number | undefined;
    constructor(limit: number, offset?: number | undefined);
}
export declare class SelectIntoFieldsExpression extends SqlAstNode {
    fields: SqlSymbol[];
    constructor(fields: SqlSymbol[]);
}
