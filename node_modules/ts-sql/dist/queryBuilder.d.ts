import * as ast from "./astsql";
export interface PreparedQuery {
    toSelect: ToSelectMethod;
    build: BuildMethod;
}
export interface BinaryPredicateBuilderMethod {
    (left: string | ast.Predicate, right: string | ast.Predicate): ast.BinaryPredicate;
}
export interface IntoMethod {
    (...fields: string[]): PreparedQuery;
}
export interface LimitMethod {
    (limit: number, offset?: number): LimitedProjection;
}
export interface OrderByMethod {
    (...expressions: ast.OrderByExpression[]): OrderedProjection;
}
export interface SelectMethod {
    (element: string | ast.SelectElement | ast.SelectAll, ...moreElements: ast.SelectElement[]): Projection;
}
export interface FromMethod {
    (table: string | ast.NestedSelectStatement, alias?: string): QuerySource;
}
export interface JoinMethod {
    (table: string | ast.NestedSelectStatement, alias: string, on: ast.Expression): QuerySource;
}
export interface WhereMethod {
    (expression: ast.Expression): FilteredQuerySource;
}
export interface GroupByMethod {
    (...fields: (string | ast.GroupByItem)[]): GroupedQuerySource;
}
export interface HavingMethod {
    (condition: ast.Expression): GroupedAndFilteredQuerySource;
}
export interface ToSelectMethod {
    (): ast.SelectStatement;
}
export interface BuildMethod {
    (): ast.SqlRoot;
}
export interface QueryBuilder {
    dialect: ast.SqlDialect;
    query(): Queryable;
}
export interface Queryable {
    select: SelectMethod;
    from: FromMethod;
}
export interface QuerySource {
    join: JoinMethod;
    lefJoin: JoinMethod;
    rightJoin: JoinMethod;
    where: WhereMethod;
    select: SelectMethod;
}
export interface FilteredQuerySource {
    groupBy: GroupByMethod;
    select: SelectMethod;
}
export interface GroupedQuerySource {
    having: HavingMethod;
    select: SelectMethod;
}
export interface GroupedAndFilteredQuerySource {
    select: SelectMethod;
}
export interface Projection extends PreparedQuery {
    orderBy: OrderByMethod;
    limit: LimitMethod;
    into: IntoMethod;
}
export interface OrderedProjection extends PreparedQuery {
    orderBy: OrderByMethod;
    into: IntoMethod;
    limit: LimitMethod;
}
export interface LimitedProjection extends PreparedQuery {
    into: IntoMethod;
}
export interface QueryElementsBuilder {
    func(name: string, ...funcArgs: (string | ast.FunctionArgument)[]): ast.SimpleFunctionCall;
    column(name: string, table?: string): ast.ColumnName;
    literal(value: ast.ConstantType): ast.Constant | ast.AliasedTerm<ast.Constant>;
    variable(name: string): ast.Variable;
    exists(statement: ast.SelectStatement): ast.ExistsSelectStatement;
    nested(statement: ast.SelectStatement): ast.NestedSelectStatement;
}
export interface ExpressionBuilder {
    not(expression: ast.Expression): ast.NotExpression;
    and(left: ast.Expression, right: ast.Expression): ast.BinaryExpression<ast.LogicalOperator>;
    or(left: ast.Expression, right: ast.Expression): ast.BinaryExpression<ast.LogicalOperator>;
    xor(left: ast.Expression, right: ast.Expression): ast.BinaryExpression<ast.LogicalOperator>;
}
export interface PredicateBuilder {
    equals: BinaryPredicateBuilderMethod;
    greater: BinaryPredicateBuilderMethod;
    less: BinaryPredicateBuilderMethod;
    greaterOrEquals: BinaryPredicateBuilderMethod;
    lessOrEquals: BinaryPredicateBuilderMethod;
    notEquals: BinaryPredicateBuilderMethod;
    nullSafeEquals: BinaryPredicateBuilderMethod;
    isTrue(predicate: ast.Predicate): ast.TruthyPredicate;
    isFalse(predicate: ast.Predicate): ast.TruthyPredicate;
    isUnknown(predicate: ast.Predicate): ast.TruthyPredicate;
    in(predicate: ast.Predicate, target: ast.SelectStatement | ast.Expression[]): ast.InPredicate;
    notIn(predicate: ast.Predicate, target: ast.SelectStatement | ast.Expression[]): ast.InPredicate;
    isNull(predicate: ast.Predicate): ast.IsNullNotNullPredicate;
    isNotNull(predicate: ast.Predicate): ast.IsNullNotNullPredicate;
    binaryPredicate(left: ast.Predicate, operator: ast.ComparisonOperator, right: ast.Predicate): ast.BinaryPredicate;
    between(operand: ast.Predicate, start: ast.Predicate, end: ast.Predicate): ast.BetweenPredicate;
    notBetween(operand: ast.Predicate, start: ast.Predicate, end: ast.Predicate): ast.BetweenPredicate;
    soundsLike(left: ast.Predicate, right: ast.Predicate): ast.SoundsLikePredicate;
    like(left: ast.Predicate, right: ast.Predicate): ast.LikePredicate;
    notLike(left: ast.Predicate, right: ast.Predicate): ast.LikePredicate;
}
export declare abstract class QueryBuilderBase implements QueryBuilder, QueryElementsBuilder, ExpressionBuilder, PredicateBuilder {
    dialect: ast.SqlDialect;
    constructor(dialect: ast.SqlDialect);
    alias(node: ast.SqlAstNode, aliasName: string): ast.AliasedTerm<ast.SqlAstNode>;
    func(name: string, ...funcArgs: (string | ast.FunctionArgument)[]): ast.SimpleFunctionCall;
    column(name: string, table?: string): ast.ColumnName;
    literal(value: ast.ConstantType, alias?: string): ast.Constant | ast.AliasedTerm<ast.Constant>;
    variable(name: string): ast.Variable;
    exists(statement: ast.SelectStatement): ast.ExistsSelectStatement;
    nested(statement: ast.SelectStatement): ast.NestedSelectStatement;
    not(expression: ast.Expression): ast.NotExpression;
    and(left: ast.Expression, right: ast.Expression, ...more: ast.Expression[]): ast.BinaryExpression<ast.LogicalOperator>;
    or(left: ast.Expression, right: ast.Expression, ...more: ast.Expression[]): ast.BinaryExpression<ast.LogicalOperator>;
    xor(left: ast.Expression, right: ast.Expression): ast.BinaryExpression<ast.LogicalOperator>;
    isTrue(predicate: ast.Predicate): ast.TruthyPredicate;
    isFalse(predicate: ast.Predicate): ast.TruthyPredicate;
    isUnknown(predicate: ast.Predicate): ast.TruthyPredicate;
    in(predicate: ast.Predicate, target: ast.SelectStatement | ast.Expression[]): ast.InPredicate;
    notIn(predicate: ast.Predicate, target: ast.SelectStatement | ast.Expression[]): ast.InPredicate;
    isNull(predicate: ast.Predicate): ast.IsNullNotNullPredicate;
    isNotNull(predicate: ast.Predicate): ast.IsNullNotNullPredicate;
    binaryPredicate(left: ast.Predicate, operator: ast.ComparisonOperator, right: ast.Predicate): ast.BinaryPredicate;
    equals: BinaryPredicateBuilderMethod;
    greater: BinaryPredicateBuilderMethod;
    less: BinaryPredicateBuilderMethod;
    greaterOrEquals: BinaryPredicateBuilderMethod;
    lessOrEquals: BinaryPredicateBuilderMethod;
    notEquals: BinaryPredicateBuilderMethod;
    nullSafeEquals: BinaryPredicateBuilderMethod;
    between(operand: ast.Predicate, start: ast.Predicate, end: ast.Predicate): ast.BetweenPredicate;
    notBetween(operand: ast.Predicate, left: ast.Predicate, right: ast.Predicate): ast.BetweenPredicate;
    soundsLike(left: ast.Predicate, right: ast.Predicate): ast.SoundsLikePredicate;
    like(left: ast.Predicate, right: ast.Predicate): ast.LikePredicate;
    notLike(left: ast.Predicate, right: ast.Predicate): ast.LikePredicate;
    query(): Queryable;
    private buildBinaryPredicate(left, operator, right);
}
export declare class MySQLQueryBuilder extends QueryBuilderBase {
    constructor();
}
