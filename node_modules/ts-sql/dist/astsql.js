"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
require("reflect-metadata");
var SqlSymbolType;
(function (SqlSymbolType) {
    SqlSymbolType[SqlSymbolType["Table"] = 0] = "Table";
    SqlSymbolType[SqlSymbolType["Field"] = 1] = "Field";
    SqlSymbolType[SqlSymbolType["Variable"] = 2] = "Variable";
    SqlSymbolType[SqlSymbolType["Alias"] = 3] = "Alias";
    SqlSymbolType[SqlSymbolType["Function"] = 4] = "Function";
})(SqlSymbolType = exports.SqlSymbolType || (exports.SqlSymbolType = {}));
var SqlNodeType;
(function (SqlNodeType) {
    SqlNodeType[SqlNodeType["Undefined"] = 0] = "Undefined";
    SqlNodeType[SqlNodeType["NotImplemented"] = 1] = "NotImplemented";
    SqlNodeType[SqlNodeType["SqlRoot"] = 2] = "SqlRoot";
    SqlNodeType[SqlNodeType["SelectStatement"] = 3] = "SelectStatement";
    SqlNodeType[SqlNodeType["QueryExpression"] = 4] = "QueryExpression";
    SqlNodeType[SqlNodeType["QueryIntoExpression"] = 5] = "QueryIntoExpression";
    SqlNodeType[SqlNodeType["UnionGroupStatement"] = 6] = "UnionGroupStatement";
    SqlNodeType[SqlNodeType["UnionStatement"] = 7] = "UnionStatement";
    SqlNodeType[SqlNodeType["AllColumns"] = 8] = "AllColumns";
    SqlNodeType[SqlNodeType["ColumnName"] = 9] = "ColumnName";
    SqlNodeType[SqlNodeType["SimpleFunctionCall"] = 10] = "SimpleFunctionCall";
    SqlNodeType[SqlNodeType["CaseExpression"] = 11] = "CaseExpression";
    SqlNodeType[SqlNodeType["CaseBranchExpression"] = 12] = "CaseBranchExpression";
    SqlNodeType[SqlNodeType["Constant"] = 13] = "Constant";
    SqlNodeType[SqlNodeType["AliasedTerm"] = 14] = "AliasedTerm";
    SqlNodeType[SqlNodeType["AssignedTerm"] = 15] = "AssignedTerm";
    SqlNodeType[SqlNodeType["NotExpression"] = 16] = "NotExpression";
    SqlNodeType[SqlNodeType["BinaryExpression"] = 17] = "BinaryExpression";
    SqlNodeType[SqlNodeType["TruthyPredicate"] = 18] = "TruthyPredicate";
    SqlNodeType[SqlNodeType["InPredicate"] = 19] = "InPredicate";
    SqlNodeType[SqlNodeType["IsNullNotNullPredicate"] = 20] = "IsNullNotNullPredicate";
    SqlNodeType[SqlNodeType["BinaryPredicate"] = 21] = "BinaryPredicate";
    SqlNodeType[SqlNodeType["QuantifiedSelectStatement"] = 22] = "QuantifiedSelectStatement";
    SqlNodeType[SqlNodeType["BetweenPredicate"] = 23] = "BetweenPredicate";
    SqlNodeType[SqlNodeType["SoundsLikePredicate"] = 24] = "SoundsLikePredicate";
    SqlNodeType[SqlNodeType["LikePredicate"] = 25] = "LikePredicate";
    SqlNodeType[SqlNodeType["AssignedExpressionAtom"] = 26] = "AssignedExpressionAtom";
    SqlNodeType[SqlNodeType["Variable"] = 27] = "Variable";
    SqlNodeType[SqlNodeType["UnaryExpressionAtom"] = 28] = "UnaryExpressionAtom";
    SqlNodeType[SqlNodeType["BinaryModifiedExpression"] = 29] = "BinaryModifiedExpression";
    SqlNodeType[SqlNodeType["RowExpression"] = 30] = "RowExpression";
    SqlNodeType[SqlNodeType["IntervalExpression"] = 31] = "IntervalExpression";
    SqlNodeType[SqlNodeType["BinaryExpressionAtom"] = 32] = "BinaryExpressionAtom";
    SqlNodeType[SqlNodeType["NestedSelectStatement"] = 33] = "NestedSelectStatement";
    SqlNodeType[SqlNodeType["ExistsSelectStatement"] = 34] = "ExistsSelectStatement";
    SqlNodeType[SqlNodeType["FromClause"] = 35] = "FromClause";
    SqlNodeType[SqlNodeType["TableSource"] = 36] = "TableSource";
    SqlNodeType[SqlNodeType["TableSpec"] = 37] = "TableSpec";
    SqlNodeType[SqlNodeType["WhereClause"] = 38] = "WhereClause";
    SqlNodeType[SqlNodeType["GroupByClause"] = 39] = "GroupByClause";
    SqlNodeType[SqlNodeType["GroupByItem"] = 40] = "GroupByItem";
    SqlNodeType[SqlNodeType["JoinClause"] = 41] = "JoinClause";
    SqlNodeType[SqlNodeType["OrderByClause"] = 42] = "OrderByClause";
    SqlNodeType[SqlNodeType["OrderByExpression"] = 43] = "OrderByExpression";
    SqlNodeType[SqlNodeType["LimitClause"] = 44] = "LimitClause";
    SqlNodeType[SqlNodeType["SelectIntoFieldsExpression"] = 45] = "SelectIntoFieldsExpression";
})(SqlNodeType = exports.SqlNodeType || (exports.SqlNodeType = {}));
exports.NodeTypeKey = Symbol("SqlAst:NodeType");
exports.SqlNodeMarker = function (nodeType) {
    return function (constructor) {
        return class extends constructor {
            constructor(...args) {
                super(...args);
                if (!(this instanceof SqlAstNode)) {
                    throw Error("Invalid node type found");
                }
                this.nodeType = nodeType;
                Reflect.defineMetadata(exports.NodeTypeKey, nodeType, this);
            }
        };
    };
};
function getSqlNodeType(node) {
    let type = Reflect.getMetadata(exports.NodeTypeKey, node);
    return SqlNodeType[type];
}
exports.getSqlNodeType = getSqlNodeType;
class SqlAstNode {
    static getNodeType(node) {
        if (node instanceof SqlAstNode) {
            return getSqlNodeType(node);
        }
        let anyNode = node;
        if (anyNode.nodeType) {
            return SqlNodeType[anyNode.nodeType];
        }
        throw Error("Node type not found.");
    }
}
exports.SqlAstNode = SqlAstNode;
let NotImplemented = class NotImplemented extends SqlAstNode {
};
NotImplemented = __decorate([
    exports.SqlNodeMarker(SqlNodeType.NotImplemented)
], NotImplemented);
exports.NotImplemented = NotImplemented;
let SqlRoot = class SqlRoot extends SqlAstNode {
    constructor(dialect, statements = []) {
        super();
        this.dialect = dialect;
        this.statements = statements;
    }
};
SqlRoot = __decorate([
    exports.SqlNodeMarker(SqlNodeType.SqlRoot),
    __metadata("design:paramtypes", [String, Array])
], SqlRoot);
exports.SqlRoot = SqlRoot;
let SelectStatement = class SelectStatement extends SqlAstNode {
    constructor(query) {
        super();
        this.query = query;
    }
};
SelectStatement = __decorate([
    exports.SqlNodeMarker(SqlNodeType.SelectStatement),
    __metadata("design:paramtypes", [Object])
], SelectStatement);
exports.SelectStatement = SelectStatement;
let QueryExpression = class QueryExpression extends SqlAstNode {
    constructor(elements = []) {
        super();
        this.elements = elements;
    }
};
QueryExpression = __decorate([
    exports.SqlNodeMarker(SqlNodeType.QueryExpression),
    __metadata("design:paramtypes", [Array])
], QueryExpression);
exports.QueryExpression = QueryExpression;
let QueryIntoExpression = class QueryIntoExpression extends SqlAstNode {
    constructor(query) {
        super();
        this.query = query;
    }
};
QueryIntoExpression = __decorate([
    exports.SqlNodeMarker(SqlNodeType.QueryIntoExpression),
    __metadata("design:paramtypes", [QueryExpression])
], QueryIntoExpression);
exports.QueryIntoExpression = QueryIntoExpression;
let UnionStatement = class UnionStatement extends SqlAstNode {
    constructor(unionWith, unionType = "ALL") {
        super();
        this.unionWith = unionWith;
        this.unionType = unionType;
    }
};
UnionStatement = __decorate([
    exports.SqlNodeMarker(SqlNodeType.UnionStatement),
    __metadata("design:paramtypes", [QueryExpression, String])
], UnionStatement);
exports.UnionStatement = UnionStatement;
let UnionGroupStatement = class UnionGroupStatement extends SqlAstNode {
    constructor(query) {
        super();
        this.query = query;
    }
};
UnionGroupStatement = __decorate([
    exports.SqlNodeMarker(SqlNodeType.UnionGroupStatement),
    __metadata("design:paramtypes", [QueryExpression])
], UnionGroupStatement);
exports.UnionGroupStatement = UnionGroupStatement;
// Represents table.*
let AllColumns = class AllColumns extends SqlAstNode {
    constructor(table) {
        super();
        this.table = table;
    }
};
AllColumns = __decorate([
    exports.SqlNodeMarker(SqlNodeType.AllColumns),
    __metadata("design:paramtypes", [Object])
], AllColumns);
exports.AllColumns = AllColumns;
let ColumnName = class ColumnName extends SqlAstNode {
    constructor(name, table) {
        super();
        this.name = name;
        this.table = table;
    }
};
ColumnName = __decorate([
    exports.SqlNodeMarker(SqlNodeType.ColumnName),
    __metadata("design:paramtypes", [Object, Object])
], ColumnName);
exports.ColumnName = ColumnName;
let SimpleFunctionCall = class SimpleFunctionCall extends SqlAstNode {
    constructor(name, args) {
        super();
        this.name = name;
        this.args = args;
    }
};
SimpleFunctionCall = __decorate([
    exports.SqlNodeMarker(SqlNodeType.SimpleFunctionCall),
    __metadata("design:paramtypes", [Object, Array])
], SimpleFunctionCall);
exports.SimpleFunctionCall = SimpleFunctionCall;
let CaseExpression = class CaseExpression extends SqlAstNode {
    constructor(expression) {
        super();
        this.expression = expression;
        this.branches = [];
    }
};
CaseExpression = __decorate([
    exports.SqlNodeMarker(SqlNodeType.CaseExpression),
    __metadata("design:paramtypes", [Object])
], CaseExpression);
exports.CaseExpression = CaseExpression;
let CaseBranchExpression = class CaseBranchExpression extends SqlAstNode {
    constructor(expression, result) {
        super();
        this.expression = expression;
        this.result = result;
    }
};
CaseBranchExpression = __decorate([
    exports.SqlNodeMarker(SqlNodeType.CaseBranchExpression),
    __metadata("design:paramtypes", [Object, Object])
], CaseBranchExpression);
exports.CaseBranchExpression = CaseBranchExpression;
let Constant = class Constant extends SqlAstNode {
    constructor(value) {
        super();
        this.value = value;
    }
};
Constant = __decorate([
    exports.SqlNodeMarker(SqlNodeType.Constant),
    __metadata("design:paramtypes", [Object])
], Constant);
exports.Constant = Constant;
let AliasedTerm = class AliasedTerm extends SqlAstNode {
    constructor(term, alias) {
        super();
        this.term = term;
        this.alias = alias;
    }
};
AliasedTerm = __decorate([
    exports.SqlNodeMarker(SqlNodeType.AliasedTerm),
    __metadata("design:paramtypes", [Object, Object])
], AliasedTerm);
exports.AliasedTerm = AliasedTerm;
let AssignedTerm = class AssignedTerm extends SqlAstNode {
    constructor(value, variable) {
        super();
        this.value = value;
        this.variable = variable;
    }
};
AssignedTerm = __decorate([
    exports.SqlNodeMarker(SqlNodeType.AssignedTerm),
    __metadata("design:paramtypes", [Object, Object])
], AssignedTerm);
exports.AssignedTerm = AssignedTerm;
let NotExpression = class NotExpression extends SqlAstNode {
    constructor(expression) {
        super();
        this.expression = expression;
    }
};
NotExpression = __decorate([
    exports.SqlNodeMarker(SqlNodeType.NotExpression),
    __metadata("design:paramtypes", [Object])
], NotExpression);
exports.NotExpression = NotExpression;
let BinaryExpression = class BinaryExpression extends SqlAstNode {
    constructor(left, operator, right) {
        super();
        this.left = left;
        this.operator = operator;
        this.right = right;
    }
};
BinaryExpression = __decorate([
    exports.SqlNodeMarker(SqlNodeType.BinaryExpression),
    __metadata("design:paramtypes", [Object, Object, Object])
], BinaryExpression);
exports.BinaryExpression = BinaryExpression;
let TruthyPredicate = class TruthyPredicate extends SqlAstNode {
    // predicate IS TRUE | predicate IS FALSE | predicate IS UNKNOWN
    // testValue?: boolean;    // TRUE | FALSE | UNKNOWN
    constructor(predicate, negate = false, testValue) {
        super();
        this.predicate = predicate;
        this.negate = negate;
        this.testValue = testValue;
    }
};
TruthyPredicate = __decorate([
    exports.SqlNodeMarker(SqlNodeType.TruthyPredicate),
    __metadata("design:paramtypes", [Object, Boolean, Boolean])
], TruthyPredicate);
exports.TruthyPredicate = TruthyPredicate;
let InPredicate = class InPredicate extends SqlAstNode {
    // negate: boolean;    // Default to false
    constructor(predicate, target, negate = false) {
        super();
        this.predicate = predicate;
        this.target = target;
        this.negate = negate;
    }
};
InPredicate = __decorate([
    exports.SqlNodeMarker(SqlNodeType.InPredicate),
    __metadata("design:paramtypes", [Object, Object, Boolean])
], InPredicate);
exports.InPredicate = InPredicate;
let IsNullNotNullPredicate = class IsNullNotNullPredicate extends SqlAstNode {
    constructor(predicate, checkWith) {
        super();
        this.predicate = predicate;
        this.checkWith = checkWith;
    }
};
IsNullNotNullPredicate = __decorate([
    exports.SqlNodeMarker(SqlNodeType.IsNullNotNullPredicate),
    __metadata("design:paramtypes", [Object, String])
], IsNullNotNullPredicate);
exports.IsNullNotNullPredicate = IsNullNotNullPredicate;
let BinaryPredicate = class BinaryPredicate extends SqlAstNode {
    constructor(left, operator, right) {
        super();
        this.left = left;
        this.operator = operator;
        this.right = right;
    }
};
BinaryPredicate = __decorate([
    exports.SqlNodeMarker(SqlNodeType.BinaryPredicate),
    __metadata("design:paramtypes", [Object, String, Object])
], BinaryPredicate);
exports.BinaryPredicate = BinaryPredicate;
let QuantifiedSelectStatement = class QuantifiedSelectStatement extends SqlAstNode {
    constructor(quantifier, statement) {
        super();
        this.quantifier = quantifier;
        this.statement = statement;
    }
};
QuantifiedSelectStatement = __decorate([
    exports.SqlNodeMarker(SqlNodeType.QuantifiedSelectStatement),
    __metadata("design:paramtypes", [String, SelectStatement])
], QuantifiedSelectStatement);
exports.QuantifiedSelectStatement = QuantifiedSelectStatement;
let BetweenPredicate = class BetweenPredicate extends SqlAstNode {
    constructor(operand, left, right, negate = false) {
        super();
        this.operand = operand;
        this.left = left;
        this.right = right;
        this.negate = negate;
    }
};
BetweenPredicate = __decorate([
    exports.SqlNodeMarker(SqlNodeType.BetweenPredicate),
    __metadata("design:paramtypes", [Object, Object, Object, Boolean])
], BetweenPredicate);
exports.BetweenPredicate = BetweenPredicate;
let SoundsLikePredicate = class SoundsLikePredicate extends SqlAstNode {
    constructor(left, right) {
        super();
        this.left = left;
        this.right = right;
    }
};
SoundsLikePredicate = __decorate([
    exports.SqlNodeMarker(SqlNodeType.SoundsLikePredicate),
    __metadata("design:paramtypes", [Object, Object])
], SoundsLikePredicate);
exports.SoundsLikePredicate = SoundsLikePredicate;
let LikePredicate = class LikePredicate extends SqlAstNode {
    constructor(left, right, negate = false) {
        super();
        this.left = left;
        this.right = right;
        this.negate = negate;
    }
};
LikePredicate = __decorate([
    exports.SqlNodeMarker(SqlNodeType.LikePredicate),
    __metadata("design:paramtypes", [Object, Object, Boolean])
], LikePredicate);
exports.LikePredicate = LikePredicate;
let AssignedExpressionAtom = class AssignedExpressionAtom extends SqlAstNode {
    constructor(expression, variable) {
        super();
        this.expression = expression;
        this.variable = variable;
    }
};
AssignedExpressionAtom = __decorate([
    exports.SqlNodeMarker(SqlNodeType.AssignedExpressionAtom),
    __metadata("design:paramtypes", [Object, Object])
], AssignedExpressionAtom);
exports.AssignedExpressionAtom = AssignedExpressionAtom;
let Variable = class Variable extends SqlAstNode {
    constructor(name) {
        super();
        this.name = name;
    }
};
Variable = __decorate([
    exports.SqlNodeMarker(SqlNodeType.Variable),
    __metadata("design:paramtypes", [Object])
], Variable);
exports.Variable = Variable;
let UnaryExpressionAtom = class UnaryExpressionAtom extends SqlAstNode {
    constructor(operator, expression) {
        super();
        this.operator = operator;
        this.expression = expression;
    }
};
UnaryExpressionAtom = __decorate([
    exports.SqlNodeMarker(SqlNodeType.UnaryExpressionAtom),
    __metadata("design:paramtypes", [String, Object])
], UnaryExpressionAtom);
exports.UnaryExpressionAtom = UnaryExpressionAtom;
let BinaryModifiedExpression = class BinaryModifiedExpression extends SqlAstNode {
    constructor(expression) {
        super();
        this.expression = expression;
    }
};
BinaryModifiedExpression = __decorate([
    exports.SqlNodeMarker(SqlNodeType.BinaryModifiedExpression),
    __metadata("design:paramtypes", [Object])
], BinaryModifiedExpression);
exports.BinaryModifiedExpression = BinaryModifiedExpression;
let RowExpression = class RowExpression extends SqlAstNode {
    constructor(expressions) {
        super();
        this.expressions = expressions;
    }
};
RowExpression = __decorate([
    exports.SqlNodeMarker(SqlNodeType.RowExpression),
    __metadata("design:paramtypes", [Array])
], RowExpression);
exports.RowExpression = RowExpression;
let IntervalExpression = class IntervalExpression extends SqlAstNode {
    constructor(expression, intervalType) {
        super();
        this.expression = expression;
        this.intervalType = intervalType;
    }
};
IntervalExpression = __decorate([
    exports.SqlNodeMarker(SqlNodeType.IntervalExpression),
    __metadata("design:paramtypes", [Object, String])
], IntervalExpression);
exports.IntervalExpression = IntervalExpression;
let BinaryExpressionAtom = class BinaryExpressionAtom extends SqlAstNode {
    constructor(left, operator, right) {
        super();
        this.left = left;
        this.operator = operator;
        this.right = right;
    }
};
BinaryExpressionAtom = __decorate([
    exports.SqlNodeMarker(SqlNodeType.BinaryExpressionAtom),
    __metadata("design:paramtypes", [Object, Object, Object])
], BinaryExpressionAtom);
exports.BinaryExpressionAtom = BinaryExpressionAtom;
let NestedSelectStatement = class NestedSelectStatement extends SqlAstNode {
    constructor(statement) {
        super();
        this.statement = statement;
    }
};
NestedSelectStatement = __decorate([
    exports.SqlNodeMarker(SqlNodeType.NestedSelectStatement),
    __metadata("design:paramtypes", [SelectStatement])
], NestedSelectStatement);
exports.NestedSelectStatement = NestedSelectStatement;
// TODO: To be filled out
let ExistsSelectStatement = class ExistsSelectStatement extends SqlAstNode {
    constructor(statement) {
        super();
        this.statement = statement;
    }
};
ExistsSelectStatement = __decorate([
    exports.SqlNodeMarker(SqlNodeType.ExistsSelectStatement),
    __metadata("design:paramtypes", [SelectStatement])
], ExistsSelectStatement);
exports.ExistsSelectStatement = ExistsSelectStatement;
let FromClause = class FromClause extends SqlAstNode {
    constructor(tables) {
        super();
        this.tables = tables;
    }
};
FromClause = __decorate([
    exports.SqlNodeMarker(SqlNodeType.FromClause),
    __metadata("design:paramtypes", [Array])
], FromClause);
exports.FromClause = FromClause;
let TableSource = class TableSource extends SqlAstNode {
    constructor(tableSourceItem) {
        super();
        this.tableSourceItem = tableSourceItem;
    }
};
TableSource = __decorate([
    exports.SqlNodeMarker(SqlNodeType.TableSource),
    __metadata("design:paramtypes", [Object])
], TableSource);
exports.TableSource = TableSource;
let TableSpec = class TableSpec extends SqlAstNode {
    constructor(tableName) {
        super();
        this.tableName = tableName;
    }
};
TableSpec = __decorate([
    exports.SqlNodeMarker(SqlNodeType.TableSpec),
    __metadata("design:paramtypes", [Object])
], TableSpec);
exports.TableSpec = TableSpec;
let WhereClause = class WhereClause extends SqlAstNode {
    constructor(expression) {
        super();
        this.expression = expression;
    }
};
WhereClause = __decorate([
    exports.SqlNodeMarker(SqlNodeType.WhereClause),
    __metadata("design:paramtypes", [Object])
], WhereClause);
exports.WhereClause = WhereClause;
let GroupByClause = class GroupByClause extends SqlAstNode {
    constructor(items, rollup = false) {
        super();
        this.items = items;
        this.rollup = rollup;
    }
};
GroupByClause = __decorate([
    exports.SqlNodeMarker(SqlNodeType.GroupByClause),
    __metadata("design:paramtypes", [Array, Boolean])
], GroupByClause);
exports.GroupByClause = GroupByClause;
let GroupByItem = class GroupByItem extends SqlAstNode {
    // descending: ASC | DESC
    constructor(expression, descending = false) {
        super();
        this.expression = expression;
        this.descending = descending;
    }
};
GroupByItem = __decorate([
    exports.SqlNodeMarker(SqlNodeType.GroupByItem),
    __metadata("design:paramtypes", [Object, Boolean])
], GroupByItem);
exports.GroupByItem = GroupByItem;
let JoinClause = class JoinClause extends SqlAstNode {
    constructor(joinWith) {
        super();
        this.joinWith = joinWith;
    }
};
JoinClause = __decorate([
    exports.SqlNodeMarker(SqlNodeType.JoinClause),
    __metadata("design:paramtypes", [Object])
], JoinClause);
exports.JoinClause = JoinClause;
let OrderByClause = class OrderByClause extends SqlAstNode {
    constructor(expressions) {
        super();
        this.expressions = expressions;
    }
};
OrderByClause = __decorate([
    exports.SqlNodeMarker(SqlNodeType.OrderByClause),
    __metadata("design:paramtypes", [Array])
], OrderByClause);
exports.OrderByClause = OrderByClause;
let OrderByExpression = class OrderByExpression extends SqlAstNode {
    constructor(expression, descending = false) {
        super();
        this.expression = expression;
        this.descending = descending;
    }
};
OrderByExpression = __decorate([
    exports.SqlNodeMarker(SqlNodeType.OrderByExpression),
    __metadata("design:paramtypes", [Object, Boolean])
], OrderByExpression);
exports.OrderByExpression = OrderByExpression;
let LimitClause = class LimitClause extends SqlAstNode {
    constructor(limit, offset) {
        super();
        this.limit = limit;
        this.offset = offset;
    }
};
LimitClause = __decorate([
    exports.SqlNodeMarker(SqlNodeType.LimitClause),
    __metadata("design:paramtypes", [Number, Number])
], LimitClause);
exports.LimitClause = LimitClause;
let SelectIntoFieldsExpression = class SelectIntoFieldsExpression extends SqlAstNode {
    constructor(fields) {
        super();
        this.fields = fields;
    }
};
SelectIntoFieldsExpression = __decorate([
    exports.SqlNodeMarker(SqlNodeType.SelectIntoFieldsExpression),
    __metadata("design:paramtypes", [Array])
], SelectIntoFieldsExpression);
exports.SelectIntoFieldsExpression = SelectIntoFieldsExpression;
//# sourceMappingURL=astsql.js.map